/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef HulkProxyServ_H
#define HulkProxyServ_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "hulk_proxy_types.h"

namespace hulk {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class HulkProxyServIf {
 public:
  virtual ~HulkProxyServIf() {}
  virtual void mpush(const std::map<std::string, std::string> & key_vals) = 0;
  virtual void push(const std::string& key, const std::string& val) = 0;
  virtual void hmpush(const std::string& hash, const std::map<std::string, std::string> & key_vals) = 0;
  virtual void mhmpush(const std::map<std::string, std::map<std::string, std::string> > & hkey_vals) = 0;
  virtual void hpush(const std::string& hash, const std::string& key, const std::string& value) = 0;
  virtual void get(std::string& _return, const std::string& key) = 0;
  virtual void hget(std::string& _return, const std::string& hash, const std::string& key) = 0;
  virtual void mget(std::map<std::string, std::string> & _return, const std::set<std::string> & keys) = 0;
  virtual void mhmget(std::map<std::string, std::map<std::string, std::string> > & _return, const std::map<std::string, std::set<std::string> > & h_keys) = 0;
  virtual void hmget(std::map<std::string, std::string> & _return, const std::string& hash, const std::set<std::string> & keys) = 0;
  virtual void hgetall(std::map<std::string, std::string> & _return, const std::string& hash) = 0;
  virtual void hgetall_limit(std::map<std::string, std::string> & _return, const std::string& hash, const int32_t limit) = 0;
  virtual void hscan( ::hulk::ScanData& _return, const std::string& hash, const std::string& cursor, const int32_t count) = 0;
  virtual void hdel(const std::string& hash, const std::string& key) = 0;
  virtual void hmdel(const std::string& hash, const std::set<std::string> & key) = 0;
  virtual void hdel_all(const std::string& hash) = 0;
  virtual void expire(const int32_t ttl) = 0;
};

class HulkProxyServIfFactory {
 public:
  typedef HulkProxyServIf Handler;

  virtual ~HulkProxyServIfFactory() {}

  virtual HulkProxyServIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(HulkProxyServIf* /* handler */) = 0;
};

class HulkProxyServIfSingletonFactory : virtual public HulkProxyServIfFactory {
 public:
  HulkProxyServIfSingletonFactory(const ::apache::thrift::stdcxx::shared_ptr<HulkProxyServIf>& iface) : iface_(iface) {}
  virtual ~HulkProxyServIfSingletonFactory() {}

  virtual HulkProxyServIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(HulkProxyServIf* /* handler */) {}

 protected:
  ::apache::thrift::stdcxx::shared_ptr<HulkProxyServIf> iface_;
};

class HulkProxyServNull : virtual public HulkProxyServIf {
 public:
  virtual ~HulkProxyServNull() {}
  void mpush(const std::map<std::string, std::string> & /* key_vals */) {
    return;
  }
  void push(const std::string& /* key */, const std::string& /* val */) {
    return;
  }
  void hmpush(const std::string& /* hash */, const std::map<std::string, std::string> & /* key_vals */) {
    return;
  }
  void mhmpush(const std::map<std::string, std::map<std::string, std::string> > & /* hkey_vals */) {
    return;
  }
  void hpush(const std::string& /* hash */, const std::string& /* key */, const std::string& /* value */) {
    return;
  }
  void get(std::string& /* _return */, const std::string& /* key */) {
    return;
  }
  void hget(std::string& /* _return */, const std::string& /* hash */, const std::string& /* key */) {
    return;
  }
  void mget(std::map<std::string, std::string> & /* _return */, const std::set<std::string> & /* keys */) {
    return;
  }
  void mhmget(std::map<std::string, std::map<std::string, std::string> > & /* _return */, const std::map<std::string, std::set<std::string> > & /* h_keys */) {
    return;
  }
  void hmget(std::map<std::string, std::string> & /* _return */, const std::string& /* hash */, const std::set<std::string> & /* keys */) {
    return;
  }
  void hgetall(std::map<std::string, std::string> & /* _return */, const std::string& /* hash */) {
    return;
  }
  void hgetall_limit(std::map<std::string, std::string> & /* _return */, const std::string& /* hash */, const int32_t /* limit */) {
    return;
  }
  void hscan( ::hulk::ScanData& /* _return */, const std::string& /* hash */, const std::string& /* cursor */, const int32_t /* count */) {
    return;
  }
  void hdel(const std::string& /* hash */, const std::string& /* key */) {
    return;
  }
  void hmdel(const std::string& /* hash */, const std::set<std::string> & /* key */) {
    return;
  }
  void hdel_all(const std::string& /* hash */) {
    return;
  }
  void expire(const int32_t /* ttl */) {
    return;
  }
};

typedef struct _HulkProxyServ_mpush_args__isset {
  _HulkProxyServ_mpush_args__isset() : key_vals(false) {}
  bool key_vals :1;
} _HulkProxyServ_mpush_args__isset;

class HulkProxyServ_mpush_args {
 public:

  HulkProxyServ_mpush_args(const HulkProxyServ_mpush_args&);
  HulkProxyServ_mpush_args& operator=(const HulkProxyServ_mpush_args&);
  HulkProxyServ_mpush_args() {
  }

  virtual ~HulkProxyServ_mpush_args() throw();
  std::map<std::string, std::string>  key_vals;

  _HulkProxyServ_mpush_args__isset __isset;

  void __set_key_vals(const std::map<std::string, std::string> & val);

  bool operator == (const HulkProxyServ_mpush_args & rhs) const
  {
    if (!(key_vals == rhs.key_vals))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_mpush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_mpush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_mpush_pargs {
 public:


  virtual ~HulkProxyServ_mpush_pargs() throw();
  const std::map<std::string, std::string> * key_vals;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_push_args__isset {
  _HulkProxyServ_push_args__isset() : key(false), val(false) {}
  bool key :1;
  bool val :1;
} _HulkProxyServ_push_args__isset;

class HulkProxyServ_push_args {
 public:

  HulkProxyServ_push_args(const HulkProxyServ_push_args&);
  HulkProxyServ_push_args& operator=(const HulkProxyServ_push_args&);
  HulkProxyServ_push_args() : key(), val() {
  }

  virtual ~HulkProxyServ_push_args() throw();
  std::string key;
  std::string val;

  _HulkProxyServ_push_args__isset __isset;

  void __set_key(const std::string& val);

  void __set_val(const std::string& val);

  bool operator == (const HulkProxyServ_push_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(val == rhs.val))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_push_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_push_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_push_pargs {
 public:


  virtual ~HulkProxyServ_push_pargs() throw();
  const std::string* key;
  const std::string* val;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hmpush_args__isset {
  _HulkProxyServ_hmpush_args__isset() : hash(false), key_vals(false) {}
  bool hash :1;
  bool key_vals :1;
} _HulkProxyServ_hmpush_args__isset;

class HulkProxyServ_hmpush_args {
 public:

  HulkProxyServ_hmpush_args(const HulkProxyServ_hmpush_args&);
  HulkProxyServ_hmpush_args& operator=(const HulkProxyServ_hmpush_args&);
  HulkProxyServ_hmpush_args() : hash() {
  }

  virtual ~HulkProxyServ_hmpush_args() throw();
  std::string hash;
  std::map<std::string, std::string>  key_vals;

  _HulkProxyServ_hmpush_args__isset __isset;

  void __set_hash(const std::string& val);

  void __set_key_vals(const std::map<std::string, std::string> & val);

  bool operator == (const HulkProxyServ_hmpush_args & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    if (!(key_vals == rhs.key_vals))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hmpush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hmpush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hmpush_pargs {
 public:


  virtual ~HulkProxyServ_hmpush_pargs() throw();
  const std::string* hash;
  const std::map<std::string, std::string> * key_vals;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_mhmpush_args__isset {
  _HulkProxyServ_mhmpush_args__isset() : hkey_vals(false) {}
  bool hkey_vals :1;
} _HulkProxyServ_mhmpush_args__isset;

class HulkProxyServ_mhmpush_args {
 public:

  HulkProxyServ_mhmpush_args(const HulkProxyServ_mhmpush_args&);
  HulkProxyServ_mhmpush_args& operator=(const HulkProxyServ_mhmpush_args&);
  HulkProxyServ_mhmpush_args() {
  }

  virtual ~HulkProxyServ_mhmpush_args() throw();
  std::map<std::string, std::map<std::string, std::string> >  hkey_vals;

  _HulkProxyServ_mhmpush_args__isset __isset;

  void __set_hkey_vals(const std::map<std::string, std::map<std::string, std::string> > & val);

  bool operator == (const HulkProxyServ_mhmpush_args & rhs) const
  {
    if (!(hkey_vals == rhs.hkey_vals))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_mhmpush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_mhmpush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_mhmpush_pargs {
 public:


  virtual ~HulkProxyServ_mhmpush_pargs() throw();
  const std::map<std::string, std::map<std::string, std::string> > * hkey_vals;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hpush_args__isset {
  _HulkProxyServ_hpush_args__isset() : hash(false), key(false), value(false) {}
  bool hash :1;
  bool key :1;
  bool value :1;
} _HulkProxyServ_hpush_args__isset;

class HulkProxyServ_hpush_args {
 public:

  HulkProxyServ_hpush_args(const HulkProxyServ_hpush_args&);
  HulkProxyServ_hpush_args& operator=(const HulkProxyServ_hpush_args&);
  HulkProxyServ_hpush_args() : hash(), key(), value() {
  }

  virtual ~HulkProxyServ_hpush_args() throw();
  std::string hash;
  std::string key;
  std::string value;

  _HulkProxyServ_hpush_args__isset __isset;

  void __set_hash(const std::string& val);

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  bool operator == (const HulkProxyServ_hpush_args & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hpush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hpush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hpush_pargs {
 public:


  virtual ~HulkProxyServ_hpush_pargs() throw();
  const std::string* hash;
  const std::string* key;
  const std::string* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_get_args__isset {
  _HulkProxyServ_get_args__isset() : key(false) {}
  bool key :1;
} _HulkProxyServ_get_args__isset;

class HulkProxyServ_get_args {
 public:

  HulkProxyServ_get_args(const HulkProxyServ_get_args&);
  HulkProxyServ_get_args& operator=(const HulkProxyServ_get_args&);
  HulkProxyServ_get_args() : key() {
  }

  virtual ~HulkProxyServ_get_args() throw();
  std::string key;

  _HulkProxyServ_get_args__isset __isset;

  void __set_key(const std::string& val);

  bool operator == (const HulkProxyServ_get_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_get_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_get_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_get_pargs {
 public:


  virtual ~HulkProxyServ_get_pargs() throw();
  const std::string* key;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_get_result__isset {
  _HulkProxyServ_get_result__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_get_result__isset;

class HulkProxyServ_get_result {
 public:

  HulkProxyServ_get_result(const HulkProxyServ_get_result&);
  HulkProxyServ_get_result& operator=(const HulkProxyServ_get_result&);
  HulkProxyServ_get_result() : success() {
  }

  virtual ~HulkProxyServ_get_result() throw();
  std::string success;

  _HulkProxyServ_get_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const HulkProxyServ_get_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_get_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_get_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_get_presult__isset {
  _HulkProxyServ_get_presult__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_get_presult__isset;

class HulkProxyServ_get_presult {
 public:


  virtual ~HulkProxyServ_get_presult() throw();
  std::string* success;

  _HulkProxyServ_get_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HulkProxyServ_hget_args__isset {
  _HulkProxyServ_hget_args__isset() : hash(false), key(false) {}
  bool hash :1;
  bool key :1;
} _HulkProxyServ_hget_args__isset;

class HulkProxyServ_hget_args {
 public:

  HulkProxyServ_hget_args(const HulkProxyServ_hget_args&);
  HulkProxyServ_hget_args& operator=(const HulkProxyServ_hget_args&);
  HulkProxyServ_hget_args() : hash(), key() {
  }

  virtual ~HulkProxyServ_hget_args() throw();
  std::string hash;
  std::string key;

  _HulkProxyServ_hget_args__isset __isset;

  void __set_hash(const std::string& val);

  void __set_key(const std::string& val);

  bool operator == (const HulkProxyServ_hget_args & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hget_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hget_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hget_pargs {
 public:


  virtual ~HulkProxyServ_hget_pargs() throw();
  const std::string* hash;
  const std::string* key;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hget_result__isset {
  _HulkProxyServ_hget_result__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_hget_result__isset;

class HulkProxyServ_hget_result {
 public:

  HulkProxyServ_hget_result(const HulkProxyServ_hget_result&);
  HulkProxyServ_hget_result& operator=(const HulkProxyServ_hget_result&);
  HulkProxyServ_hget_result() : success() {
  }

  virtual ~HulkProxyServ_hget_result() throw();
  std::string success;

  _HulkProxyServ_hget_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const HulkProxyServ_hget_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hget_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hget_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hget_presult__isset {
  _HulkProxyServ_hget_presult__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_hget_presult__isset;

class HulkProxyServ_hget_presult {
 public:


  virtual ~HulkProxyServ_hget_presult() throw();
  std::string* success;

  _HulkProxyServ_hget_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HulkProxyServ_mget_args__isset {
  _HulkProxyServ_mget_args__isset() : keys(false) {}
  bool keys :1;
} _HulkProxyServ_mget_args__isset;

class HulkProxyServ_mget_args {
 public:

  HulkProxyServ_mget_args(const HulkProxyServ_mget_args&);
  HulkProxyServ_mget_args& operator=(const HulkProxyServ_mget_args&);
  HulkProxyServ_mget_args() {
  }

  virtual ~HulkProxyServ_mget_args() throw();
  std::set<std::string>  keys;

  _HulkProxyServ_mget_args__isset __isset;

  void __set_keys(const std::set<std::string> & val);

  bool operator == (const HulkProxyServ_mget_args & rhs) const
  {
    if (!(keys == rhs.keys))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_mget_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_mget_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_mget_pargs {
 public:


  virtual ~HulkProxyServ_mget_pargs() throw();
  const std::set<std::string> * keys;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_mget_result__isset {
  _HulkProxyServ_mget_result__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_mget_result__isset;

class HulkProxyServ_mget_result {
 public:

  HulkProxyServ_mget_result(const HulkProxyServ_mget_result&);
  HulkProxyServ_mget_result& operator=(const HulkProxyServ_mget_result&);
  HulkProxyServ_mget_result() {
  }

  virtual ~HulkProxyServ_mget_result() throw();
  std::map<std::string, std::string>  success;

  _HulkProxyServ_mget_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val);

  bool operator == (const HulkProxyServ_mget_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_mget_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_mget_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_mget_presult__isset {
  _HulkProxyServ_mget_presult__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_mget_presult__isset;

class HulkProxyServ_mget_presult {
 public:


  virtual ~HulkProxyServ_mget_presult() throw();
  std::map<std::string, std::string> * success;

  _HulkProxyServ_mget_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HulkProxyServ_mhmget_args__isset {
  _HulkProxyServ_mhmget_args__isset() : h_keys(false) {}
  bool h_keys :1;
} _HulkProxyServ_mhmget_args__isset;

class HulkProxyServ_mhmget_args {
 public:

  HulkProxyServ_mhmget_args(const HulkProxyServ_mhmget_args&);
  HulkProxyServ_mhmget_args& operator=(const HulkProxyServ_mhmget_args&);
  HulkProxyServ_mhmget_args() {
  }

  virtual ~HulkProxyServ_mhmget_args() throw();
  std::map<std::string, std::set<std::string> >  h_keys;

  _HulkProxyServ_mhmget_args__isset __isset;

  void __set_h_keys(const std::map<std::string, std::set<std::string> > & val);

  bool operator == (const HulkProxyServ_mhmget_args & rhs) const
  {
    if (!(h_keys == rhs.h_keys))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_mhmget_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_mhmget_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_mhmget_pargs {
 public:


  virtual ~HulkProxyServ_mhmget_pargs() throw();
  const std::map<std::string, std::set<std::string> > * h_keys;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_mhmget_result__isset {
  _HulkProxyServ_mhmget_result__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_mhmget_result__isset;

class HulkProxyServ_mhmget_result {
 public:

  HulkProxyServ_mhmget_result(const HulkProxyServ_mhmget_result&);
  HulkProxyServ_mhmget_result& operator=(const HulkProxyServ_mhmget_result&);
  HulkProxyServ_mhmget_result() {
  }

  virtual ~HulkProxyServ_mhmget_result() throw();
  std::map<std::string, std::map<std::string, std::string> >  success;

  _HulkProxyServ_mhmget_result__isset __isset;

  void __set_success(const std::map<std::string, std::map<std::string, std::string> > & val);

  bool operator == (const HulkProxyServ_mhmget_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_mhmget_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_mhmget_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_mhmget_presult__isset {
  _HulkProxyServ_mhmget_presult__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_mhmget_presult__isset;

class HulkProxyServ_mhmget_presult {
 public:


  virtual ~HulkProxyServ_mhmget_presult() throw();
  std::map<std::string, std::map<std::string, std::string> > * success;

  _HulkProxyServ_mhmget_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HulkProxyServ_hmget_args__isset {
  _HulkProxyServ_hmget_args__isset() : hash(false), keys(false) {}
  bool hash :1;
  bool keys :1;
} _HulkProxyServ_hmget_args__isset;

class HulkProxyServ_hmget_args {
 public:

  HulkProxyServ_hmget_args(const HulkProxyServ_hmget_args&);
  HulkProxyServ_hmget_args& operator=(const HulkProxyServ_hmget_args&);
  HulkProxyServ_hmget_args() : hash() {
  }

  virtual ~HulkProxyServ_hmget_args() throw();
  std::string hash;
  std::set<std::string>  keys;

  _HulkProxyServ_hmget_args__isset __isset;

  void __set_hash(const std::string& val);

  void __set_keys(const std::set<std::string> & val);

  bool operator == (const HulkProxyServ_hmget_args & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    if (!(keys == rhs.keys))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hmget_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hmget_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hmget_pargs {
 public:


  virtual ~HulkProxyServ_hmget_pargs() throw();
  const std::string* hash;
  const std::set<std::string> * keys;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hmget_result__isset {
  _HulkProxyServ_hmget_result__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_hmget_result__isset;

class HulkProxyServ_hmget_result {
 public:

  HulkProxyServ_hmget_result(const HulkProxyServ_hmget_result&);
  HulkProxyServ_hmget_result& operator=(const HulkProxyServ_hmget_result&);
  HulkProxyServ_hmget_result() {
  }

  virtual ~HulkProxyServ_hmget_result() throw();
  std::map<std::string, std::string>  success;

  _HulkProxyServ_hmget_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val);

  bool operator == (const HulkProxyServ_hmget_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hmget_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hmget_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hmget_presult__isset {
  _HulkProxyServ_hmget_presult__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_hmget_presult__isset;

class HulkProxyServ_hmget_presult {
 public:


  virtual ~HulkProxyServ_hmget_presult() throw();
  std::map<std::string, std::string> * success;

  _HulkProxyServ_hmget_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HulkProxyServ_hgetall_args__isset {
  _HulkProxyServ_hgetall_args__isset() : hash(false) {}
  bool hash :1;
} _HulkProxyServ_hgetall_args__isset;

class HulkProxyServ_hgetall_args {
 public:

  HulkProxyServ_hgetall_args(const HulkProxyServ_hgetall_args&);
  HulkProxyServ_hgetall_args& operator=(const HulkProxyServ_hgetall_args&);
  HulkProxyServ_hgetall_args() : hash() {
  }

  virtual ~HulkProxyServ_hgetall_args() throw();
  std::string hash;

  _HulkProxyServ_hgetall_args__isset __isset;

  void __set_hash(const std::string& val);

  bool operator == (const HulkProxyServ_hgetall_args & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hgetall_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hgetall_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hgetall_pargs {
 public:


  virtual ~HulkProxyServ_hgetall_pargs() throw();
  const std::string* hash;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hgetall_result__isset {
  _HulkProxyServ_hgetall_result__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_hgetall_result__isset;

class HulkProxyServ_hgetall_result {
 public:

  HulkProxyServ_hgetall_result(const HulkProxyServ_hgetall_result&);
  HulkProxyServ_hgetall_result& operator=(const HulkProxyServ_hgetall_result&);
  HulkProxyServ_hgetall_result() {
  }

  virtual ~HulkProxyServ_hgetall_result() throw();
  std::map<std::string, std::string>  success;

  _HulkProxyServ_hgetall_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val);

  bool operator == (const HulkProxyServ_hgetall_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hgetall_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hgetall_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hgetall_presult__isset {
  _HulkProxyServ_hgetall_presult__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_hgetall_presult__isset;

class HulkProxyServ_hgetall_presult {
 public:


  virtual ~HulkProxyServ_hgetall_presult() throw();
  std::map<std::string, std::string> * success;

  _HulkProxyServ_hgetall_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HulkProxyServ_hgetall_limit_args__isset {
  _HulkProxyServ_hgetall_limit_args__isset() : hash(false), limit(false) {}
  bool hash :1;
  bool limit :1;
} _HulkProxyServ_hgetall_limit_args__isset;

class HulkProxyServ_hgetall_limit_args {
 public:

  HulkProxyServ_hgetall_limit_args(const HulkProxyServ_hgetall_limit_args&);
  HulkProxyServ_hgetall_limit_args& operator=(const HulkProxyServ_hgetall_limit_args&);
  HulkProxyServ_hgetall_limit_args() : hash(), limit(0) {
  }

  virtual ~HulkProxyServ_hgetall_limit_args() throw();
  std::string hash;
  int32_t limit;

  _HulkProxyServ_hgetall_limit_args__isset __isset;

  void __set_hash(const std::string& val);

  void __set_limit(const int32_t val);

  bool operator == (const HulkProxyServ_hgetall_limit_args & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    if (!(limit == rhs.limit))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hgetall_limit_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hgetall_limit_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hgetall_limit_pargs {
 public:


  virtual ~HulkProxyServ_hgetall_limit_pargs() throw();
  const std::string* hash;
  const int32_t* limit;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hgetall_limit_result__isset {
  _HulkProxyServ_hgetall_limit_result__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_hgetall_limit_result__isset;

class HulkProxyServ_hgetall_limit_result {
 public:

  HulkProxyServ_hgetall_limit_result(const HulkProxyServ_hgetall_limit_result&);
  HulkProxyServ_hgetall_limit_result& operator=(const HulkProxyServ_hgetall_limit_result&);
  HulkProxyServ_hgetall_limit_result() {
  }

  virtual ~HulkProxyServ_hgetall_limit_result() throw();
  std::map<std::string, std::string>  success;

  _HulkProxyServ_hgetall_limit_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val);

  bool operator == (const HulkProxyServ_hgetall_limit_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hgetall_limit_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hgetall_limit_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hgetall_limit_presult__isset {
  _HulkProxyServ_hgetall_limit_presult__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_hgetall_limit_presult__isset;

class HulkProxyServ_hgetall_limit_presult {
 public:


  virtual ~HulkProxyServ_hgetall_limit_presult() throw();
  std::map<std::string, std::string> * success;

  _HulkProxyServ_hgetall_limit_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HulkProxyServ_hscan_args__isset {
  _HulkProxyServ_hscan_args__isset() : hash(false), cursor(false), count(false) {}
  bool hash :1;
  bool cursor :1;
  bool count :1;
} _HulkProxyServ_hscan_args__isset;

class HulkProxyServ_hscan_args {
 public:

  HulkProxyServ_hscan_args(const HulkProxyServ_hscan_args&);
  HulkProxyServ_hscan_args& operator=(const HulkProxyServ_hscan_args&);
  HulkProxyServ_hscan_args() : hash(), cursor(), count(0) {
  }

  virtual ~HulkProxyServ_hscan_args() throw();
  std::string hash;
  std::string cursor;
  int32_t count;

  _HulkProxyServ_hscan_args__isset __isset;

  void __set_hash(const std::string& val);

  void __set_cursor(const std::string& val);

  void __set_count(const int32_t val);

  bool operator == (const HulkProxyServ_hscan_args & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    if (!(cursor == rhs.cursor))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hscan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hscan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hscan_pargs {
 public:


  virtual ~HulkProxyServ_hscan_pargs() throw();
  const std::string* hash;
  const std::string* cursor;
  const int32_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hscan_result__isset {
  _HulkProxyServ_hscan_result__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_hscan_result__isset;

class HulkProxyServ_hscan_result {
 public:

  HulkProxyServ_hscan_result(const HulkProxyServ_hscan_result&);
  HulkProxyServ_hscan_result& operator=(const HulkProxyServ_hscan_result&);
  HulkProxyServ_hscan_result() {
  }

  virtual ~HulkProxyServ_hscan_result() throw();
   ::hulk::ScanData success;

  _HulkProxyServ_hscan_result__isset __isset;

  void __set_success(const  ::hulk::ScanData& val);

  bool operator == (const HulkProxyServ_hscan_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hscan_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hscan_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hscan_presult__isset {
  _HulkProxyServ_hscan_presult__isset() : success(false) {}
  bool success :1;
} _HulkProxyServ_hscan_presult__isset;

class HulkProxyServ_hscan_presult {
 public:


  virtual ~HulkProxyServ_hscan_presult() throw();
   ::hulk::ScanData* success;

  _HulkProxyServ_hscan_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HulkProxyServ_hdel_args__isset {
  _HulkProxyServ_hdel_args__isset() : hash(false), key(false) {}
  bool hash :1;
  bool key :1;
} _HulkProxyServ_hdel_args__isset;

class HulkProxyServ_hdel_args {
 public:

  HulkProxyServ_hdel_args(const HulkProxyServ_hdel_args&);
  HulkProxyServ_hdel_args& operator=(const HulkProxyServ_hdel_args&);
  HulkProxyServ_hdel_args() : hash(), key() {
  }

  virtual ~HulkProxyServ_hdel_args() throw();
  std::string hash;
  std::string key;

  _HulkProxyServ_hdel_args__isset __isset;

  void __set_hash(const std::string& val);

  void __set_key(const std::string& val);

  bool operator == (const HulkProxyServ_hdel_args & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hdel_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hdel_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hdel_pargs {
 public:


  virtual ~HulkProxyServ_hdel_pargs() throw();
  const std::string* hash;
  const std::string* key;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HulkProxyServ_hmdel_args__isset {
  _HulkProxyServ_hmdel_args__isset() : hash(false), key(false) {}
  bool hash :1;
  bool key :1;
} _HulkProxyServ_hmdel_args__isset;

class HulkProxyServ_hmdel_args {
 public:

  HulkProxyServ_hmdel_args(const HulkProxyServ_hmdel_args&);
  HulkProxyServ_hmdel_args& operator=(const HulkProxyServ_hmdel_args&);
  HulkProxyServ_hmdel_args() : hash() {
  }

  virtual ~HulkProxyServ_hmdel_args() throw();
  std::string hash;
  std::set<std::string>  key;

  _HulkProxyServ_hmdel_args__isset __isset;

  void __set_hash(const std::string& val);

  void __set_key(const std::set<std::string> & val);

  bool operator == (const HulkProxyServ_hmdel_args & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hmdel_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hmdel_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hmdel_pargs {
 public:


  virtual ~HulkProxyServ_hmdel_pargs() throw();
  const std::string* hash;
  const std::set<std::string> * key;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hmdel_result {
 public:

  HulkProxyServ_hmdel_result(const HulkProxyServ_hmdel_result&);
  HulkProxyServ_hmdel_result& operator=(const HulkProxyServ_hmdel_result&);
  HulkProxyServ_hmdel_result() {
  }

  virtual ~HulkProxyServ_hmdel_result() throw();

  bool operator == (const HulkProxyServ_hmdel_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HulkProxyServ_hmdel_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hmdel_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hmdel_presult {
 public:


  virtual ~HulkProxyServ_hmdel_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HulkProxyServ_hdel_all_args__isset {
  _HulkProxyServ_hdel_all_args__isset() : hash(false) {}
  bool hash :1;
} _HulkProxyServ_hdel_all_args__isset;

class HulkProxyServ_hdel_all_args {
 public:

  HulkProxyServ_hdel_all_args(const HulkProxyServ_hdel_all_args&);
  HulkProxyServ_hdel_all_args& operator=(const HulkProxyServ_hdel_all_args&);
  HulkProxyServ_hdel_all_args() : hash() {
  }

  virtual ~HulkProxyServ_hdel_all_args() throw();
  std::string hash;

  _HulkProxyServ_hdel_all_args__isset __isset;

  void __set_hash(const std::string& val);

  bool operator == (const HulkProxyServ_hdel_all_args & rhs) const
  {
    if (!(hash == rhs.hash))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_hdel_all_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hdel_all_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hdel_all_pargs {
 public:


  virtual ~HulkProxyServ_hdel_all_pargs() throw();
  const std::string* hash;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hdel_all_result {
 public:

  HulkProxyServ_hdel_all_result(const HulkProxyServ_hdel_all_result&);
  HulkProxyServ_hdel_all_result& operator=(const HulkProxyServ_hdel_all_result&);
  HulkProxyServ_hdel_all_result() {
  }

  virtual ~HulkProxyServ_hdel_all_result() throw();

  bool operator == (const HulkProxyServ_hdel_all_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HulkProxyServ_hdel_all_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_hdel_all_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_hdel_all_presult {
 public:


  virtual ~HulkProxyServ_hdel_all_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HulkProxyServ_expire_args__isset {
  _HulkProxyServ_expire_args__isset() : ttl(false) {}
  bool ttl :1;
} _HulkProxyServ_expire_args__isset;

class HulkProxyServ_expire_args {
 public:

  HulkProxyServ_expire_args(const HulkProxyServ_expire_args&);
  HulkProxyServ_expire_args& operator=(const HulkProxyServ_expire_args&);
  HulkProxyServ_expire_args() : ttl(0) {
  }

  virtual ~HulkProxyServ_expire_args() throw();
  int32_t ttl;

  _HulkProxyServ_expire_args__isset __isset;

  void __set_ttl(const int32_t val);

  bool operator == (const HulkProxyServ_expire_args & rhs) const
  {
    if (!(ttl == rhs.ttl))
      return false;
    return true;
  }
  bool operator != (const HulkProxyServ_expire_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HulkProxyServ_expire_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HulkProxyServ_expire_pargs {
 public:


  virtual ~HulkProxyServ_expire_pargs() throw();
  const int32_t* ttl;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class HulkProxyServClient : virtual public HulkProxyServIf {
 public:
  HulkProxyServClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  HulkProxyServClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void mpush(const std::map<std::string, std::string> & key_vals);
  void send_mpush(const std::map<std::string, std::string> & key_vals);
  void push(const std::string& key, const std::string& val);
  void send_push(const std::string& key, const std::string& val);
  void hmpush(const std::string& hash, const std::map<std::string, std::string> & key_vals);
  void send_hmpush(const std::string& hash, const std::map<std::string, std::string> & key_vals);
  void mhmpush(const std::map<std::string, std::map<std::string, std::string> > & hkey_vals);
  void send_mhmpush(const std::map<std::string, std::map<std::string, std::string> > & hkey_vals);
  void hpush(const std::string& hash, const std::string& key, const std::string& value);
  void send_hpush(const std::string& hash, const std::string& key, const std::string& value);
  void get(std::string& _return, const std::string& key);
  void send_get(const std::string& key);
  void recv_get(std::string& _return);
  void hget(std::string& _return, const std::string& hash, const std::string& key);
  void send_hget(const std::string& hash, const std::string& key);
  void recv_hget(std::string& _return);
  void mget(std::map<std::string, std::string> & _return, const std::set<std::string> & keys);
  void send_mget(const std::set<std::string> & keys);
  void recv_mget(std::map<std::string, std::string> & _return);
  void mhmget(std::map<std::string, std::map<std::string, std::string> > & _return, const std::map<std::string, std::set<std::string> > & h_keys);
  void send_mhmget(const std::map<std::string, std::set<std::string> > & h_keys);
  void recv_mhmget(std::map<std::string, std::map<std::string, std::string> > & _return);
  void hmget(std::map<std::string, std::string> & _return, const std::string& hash, const std::set<std::string> & keys);
  void send_hmget(const std::string& hash, const std::set<std::string> & keys);
  void recv_hmget(std::map<std::string, std::string> & _return);
  void hgetall(std::map<std::string, std::string> & _return, const std::string& hash);
  void send_hgetall(const std::string& hash);
  void recv_hgetall(std::map<std::string, std::string> & _return);
  void hgetall_limit(std::map<std::string, std::string> & _return, const std::string& hash, const int32_t limit);
  void send_hgetall_limit(const std::string& hash, const int32_t limit);
  void recv_hgetall_limit(std::map<std::string, std::string> & _return);
  void hscan( ::hulk::ScanData& _return, const std::string& hash, const std::string& cursor, const int32_t count);
  void send_hscan(const std::string& hash, const std::string& cursor, const int32_t count);
  void recv_hscan( ::hulk::ScanData& _return);
  void hdel(const std::string& hash, const std::string& key);
  void send_hdel(const std::string& hash, const std::string& key);
  void hmdel(const std::string& hash, const std::set<std::string> & key);
  void send_hmdel(const std::string& hash, const std::set<std::string> & key);
  void recv_hmdel();
  void hdel_all(const std::string& hash);
  void send_hdel_all(const std::string& hash);
  void recv_hdel_all();
  void expire(const int32_t ttl);
  void send_expire(const int32_t ttl);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class HulkProxyServProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::apache::thrift::stdcxx::shared_ptr<HulkProxyServIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (HulkProxyServProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_mpush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_push(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hmpush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mhmpush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hpush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hget(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mget(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mhmget(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hmget(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hgetall(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hgetall_limit(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hscan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hdel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hmdel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hdel_all(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_expire(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  HulkProxyServProcessor(::apache::thrift::stdcxx::shared_ptr<HulkProxyServIf> iface) :
    iface_(iface) {
    processMap_["mpush"] = &HulkProxyServProcessor::process_mpush;
    processMap_["push"] = &HulkProxyServProcessor::process_push;
    processMap_["hmpush"] = &HulkProxyServProcessor::process_hmpush;
    processMap_["mhmpush"] = &HulkProxyServProcessor::process_mhmpush;
    processMap_["hpush"] = &HulkProxyServProcessor::process_hpush;
    processMap_["get"] = &HulkProxyServProcessor::process_get;
    processMap_["hget"] = &HulkProxyServProcessor::process_hget;
    processMap_["mget"] = &HulkProxyServProcessor::process_mget;
    processMap_["mhmget"] = &HulkProxyServProcessor::process_mhmget;
    processMap_["hmget"] = &HulkProxyServProcessor::process_hmget;
    processMap_["hgetall"] = &HulkProxyServProcessor::process_hgetall;
    processMap_["hgetall_limit"] = &HulkProxyServProcessor::process_hgetall_limit;
    processMap_["hscan"] = &HulkProxyServProcessor::process_hscan;
    processMap_["hdel"] = &HulkProxyServProcessor::process_hdel;
    processMap_["hmdel"] = &HulkProxyServProcessor::process_hmdel;
    processMap_["hdel_all"] = &HulkProxyServProcessor::process_hdel_all;
    processMap_["expire"] = &HulkProxyServProcessor::process_expire;
  }

  virtual ~HulkProxyServProcessor() {}
};

class HulkProxyServProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  HulkProxyServProcessorFactory(const ::apache::thrift::stdcxx::shared_ptr< HulkProxyServIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::apache::thrift::stdcxx::shared_ptr< HulkProxyServIfFactory > handlerFactory_;
};

class HulkProxyServMultiface : virtual public HulkProxyServIf {
 public:
  HulkProxyServMultiface(std::vector<apache::thrift::stdcxx::shared_ptr<HulkProxyServIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~HulkProxyServMultiface() {}
 protected:
  std::vector<apache::thrift::stdcxx::shared_ptr<HulkProxyServIf> > ifaces_;
  HulkProxyServMultiface() {}
  void add(::apache::thrift::stdcxx::shared_ptr<HulkProxyServIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void mpush(const std::map<std::string, std::string> & key_vals) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mpush(key_vals);
    }
    ifaces_[i]->mpush(key_vals);
  }

  void push(const std::string& key, const std::string& val) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->push(key, val);
    }
    ifaces_[i]->push(key, val);
  }

  void hmpush(const std::string& hash, const std::map<std::string, std::string> & key_vals) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hmpush(hash, key_vals);
    }
    ifaces_[i]->hmpush(hash, key_vals);
  }

  void mhmpush(const std::map<std::string, std::map<std::string, std::string> > & hkey_vals) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mhmpush(hkey_vals);
    }
    ifaces_[i]->mhmpush(hkey_vals);
  }

  void hpush(const std::string& hash, const std::string& key, const std::string& value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hpush(hash, key, value);
    }
    ifaces_[i]->hpush(hash, key, value);
  }

  void get(std::string& _return, const std::string& key) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get(_return, key);
    }
    ifaces_[i]->get(_return, key);
    return;
  }

  void hget(std::string& _return, const std::string& hash, const std::string& key) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hget(_return, hash, key);
    }
    ifaces_[i]->hget(_return, hash, key);
    return;
  }

  void mget(std::map<std::string, std::string> & _return, const std::set<std::string> & keys) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mget(_return, keys);
    }
    ifaces_[i]->mget(_return, keys);
    return;
  }

  void mhmget(std::map<std::string, std::map<std::string, std::string> > & _return, const std::map<std::string, std::set<std::string> > & h_keys) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mhmget(_return, h_keys);
    }
    ifaces_[i]->mhmget(_return, h_keys);
    return;
  }

  void hmget(std::map<std::string, std::string> & _return, const std::string& hash, const std::set<std::string> & keys) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hmget(_return, hash, keys);
    }
    ifaces_[i]->hmget(_return, hash, keys);
    return;
  }

  void hgetall(std::map<std::string, std::string> & _return, const std::string& hash) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hgetall(_return, hash);
    }
    ifaces_[i]->hgetall(_return, hash);
    return;
  }

  void hgetall_limit(std::map<std::string, std::string> & _return, const std::string& hash, const int32_t limit) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hgetall_limit(_return, hash, limit);
    }
    ifaces_[i]->hgetall_limit(_return, hash, limit);
    return;
  }

  void hscan( ::hulk::ScanData& _return, const std::string& hash, const std::string& cursor, const int32_t count) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hscan(_return, hash, cursor, count);
    }
    ifaces_[i]->hscan(_return, hash, cursor, count);
    return;
  }

  void hdel(const std::string& hash, const std::string& key) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hdel(hash, key);
    }
    ifaces_[i]->hdel(hash, key);
  }

  void hmdel(const std::string& hash, const std::set<std::string> & key) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hmdel(hash, key);
    }
    ifaces_[i]->hmdel(hash, key);
  }

  void hdel_all(const std::string& hash) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hdel_all(hash);
    }
    ifaces_[i]->hdel_all(hash);
  }

  void expire(const int32_t ttl) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->expire(ttl);
    }
    ifaces_[i]->expire(ttl);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class HulkProxyServConcurrentClient : virtual public HulkProxyServIf {
 public:
  HulkProxyServConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  HulkProxyServConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void mpush(const std::map<std::string, std::string> & key_vals);
  void send_mpush(const std::map<std::string, std::string> & key_vals);
  void push(const std::string& key, const std::string& val);
  void send_push(const std::string& key, const std::string& val);
  void hmpush(const std::string& hash, const std::map<std::string, std::string> & key_vals);
  void send_hmpush(const std::string& hash, const std::map<std::string, std::string> & key_vals);
  void mhmpush(const std::map<std::string, std::map<std::string, std::string> > & hkey_vals);
  void send_mhmpush(const std::map<std::string, std::map<std::string, std::string> > & hkey_vals);
  void hpush(const std::string& hash, const std::string& key, const std::string& value);
  void send_hpush(const std::string& hash, const std::string& key, const std::string& value);
  void get(std::string& _return, const std::string& key);
  int32_t send_get(const std::string& key);
  void recv_get(std::string& _return, const int32_t seqid);
  void hget(std::string& _return, const std::string& hash, const std::string& key);
  int32_t send_hget(const std::string& hash, const std::string& key);
  void recv_hget(std::string& _return, const int32_t seqid);
  void mget(std::map<std::string, std::string> & _return, const std::set<std::string> & keys);
  int32_t send_mget(const std::set<std::string> & keys);
  void recv_mget(std::map<std::string, std::string> & _return, const int32_t seqid);
  void mhmget(std::map<std::string, std::map<std::string, std::string> > & _return, const std::map<std::string, std::set<std::string> > & h_keys);
  int32_t send_mhmget(const std::map<std::string, std::set<std::string> > & h_keys);
  void recv_mhmget(std::map<std::string, std::map<std::string, std::string> > & _return, const int32_t seqid);
  void hmget(std::map<std::string, std::string> & _return, const std::string& hash, const std::set<std::string> & keys);
  int32_t send_hmget(const std::string& hash, const std::set<std::string> & keys);
  void recv_hmget(std::map<std::string, std::string> & _return, const int32_t seqid);
  void hgetall(std::map<std::string, std::string> & _return, const std::string& hash);
  int32_t send_hgetall(const std::string& hash);
  void recv_hgetall(std::map<std::string, std::string> & _return, const int32_t seqid);
  void hgetall_limit(std::map<std::string, std::string> & _return, const std::string& hash, const int32_t limit);
  int32_t send_hgetall_limit(const std::string& hash, const int32_t limit);
  void recv_hgetall_limit(std::map<std::string, std::string> & _return, const int32_t seqid);
  void hscan( ::hulk::ScanData& _return, const std::string& hash, const std::string& cursor, const int32_t count);
  int32_t send_hscan(const std::string& hash, const std::string& cursor, const int32_t count);
  void recv_hscan( ::hulk::ScanData& _return, const int32_t seqid);
  void hdel(const std::string& hash, const std::string& key);
  void send_hdel(const std::string& hash, const std::string& key);
  void hmdel(const std::string& hash, const std::set<std::string> & key);
  int32_t send_hmdel(const std::string& hash, const std::set<std::string> & key);
  void recv_hmdel(const int32_t seqid);
  void hdel_all(const std::string& hash);
  int32_t send_hdel_all(const std::string& hash);
  void recv_hdel_all(const int32_t seqid);
  void expire(const int32_t ttl);
  void send_expire(const int32_t ttl);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

} // namespace

#endif
