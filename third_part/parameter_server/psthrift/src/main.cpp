/*
 * @Company: TWL
 * @Author: xue jian
 * @Email: xuejian@kanzhun.com
 * @Date: 2019-08-13 22:23:02
 */
// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Serv.h"
#include "thread"
#include <thrift/server/TSimpleServer.h>

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/transport/TNonblockingServerSocket.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/TToString.h>
#include <memory>
#include "my_op.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;
//using namespace ::apache::thrift::server::TNonblockingServer;


// #define ZK_PATH "/namespace_gustTest/rocksdbProxy_test/version_1"
// #define ZK_URL "127.0.0.1:2181"

class ServHandler : virtual public ServIf {
 private:
  std::shared_ptr<ps::MyOp> my_op_;
 public:
  ServHandler():
  my_op_(new ps::MyOp())
  {
    // Your initialization goes here
  }

  void push(const std::map<Key, std::string> & key_vals) {
    // printf("start push\n");
    // Your implementation goes here
    my_op_->push(key_vals, false);
    // printf(" push\n");
  }


  void sync_push(const std::map<Key, std::string> & key_vals) {
    // printf("sync_push\n");
    // Your implementation goes here
    my_op_->push(key_vals, true);
    // printf("sync_push\n");
  }

  void pushemb(const std::map<Key, std::string> & key_vals) {
    // Your implementation goes here
    my_op_->pushemb(key_vals);
    // printf("pushemb\n");
  }

  void pushada(const std::map<Key, std::string> & key_vals) {
    // Your implementation goes here
    my_op_->pushada(key_vals);
    // printf("pushada\n");
  }

  void pull(std::map<Key, std::string> & _return, const std::set<Key> & keys) {
    // printf("pull\n");
    // std::cout<<"start pull "<<log_Time()<<std::endl;
    my_op_->multi_pull(_return, keys);
    // my_op_->pull(_return, keys);
    // std::cout<<"end pull "<<log_Time()<<std::endl<<"==========="<<std::endl;
    // printf("pull\n");
  }

  void pull_online(std::map<Key, std::string> & _return, const std::set<Key> & keys) {
    // printf("pull_online\n");
    // Your implementation goes here
    my_op_->pull_online(_return, keys);
    // printf("pull_online\n");
  }

  void heartbeat(std::string& _return, const int32_t input) {
    // Your implementation goes here.
    static int cnt = 0;
    _return = std::to_string(input);
    printf("heartbeat, input=%d  times=%d  \n",input, ++cnt);
  }
};


// string ps::MyOp::file_conf;
ps::Configure* ps::MyOp::conf = new ps::Configure();

int main(int argc, char **argv) {
  if (ps::MyOp::conf->parse(argc, argv) == -1) {
    return -1;
  }
  if (!ps::MyOp::conf->getmeta()) {
    // std::cout<<ps::MyOp::conf->meta<<std::endl;
    log_error("Fatal error! the meta parse error! check file '%d", 0);
    return -1;
  }
  // if (!ps::MyOp::conf->getnets()) {
  //   log_error("Fatal error! the nets parse error! check file '%d", 0);
  //   return -1;
  // }
  //this command must be ahead of the get model name;
  if (!ps::MyOp::conf->getthriftconf()) {
    log_error("Fatal error! the thrift parse error! check file '%d", 0);
    return -1;
  }

  int port;

  if (!ps::MyOp::conf->getthriftport(port)) {
    log_error("Fatal error! The thrift port is missing '%d'", 0);
    return -1;
  }


  if (!ps::MyOp::conf->getmasterport()) {
    log_error("Fatal error! The master port is missing '%d'", 0);
    return -1;
  }

  if (!ps::MyOp::conf->getslaveof()) {
    log_error("Fatal error! The slave of has wrong form '%d'", 0);
    return -1;
  }
  std::string model_name;
  if (!ps::MyOp::conf->getmodelname(model_name)) {
    log_error("Fatal error! The model name has no value '%d'", 0);
    return -1;
  }

  int num(64);

  if (!ps::MyOp::conf->getthreadnum(num)) {
    log_error("Fatal error! The thread number has no value '%d'", 0);
    return -1;
  }

  

  std::shared_ptr<ServHandler> handler(new ServHandler());
  std::shared_ptr<TProcessor> processor(new ServProcessor(handler));
  std::shared_ptr<TNonblockingServerTransport> serverTransport(new TNonblockingServerSocket(port));
  std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  std::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(num);
  std::shared_ptr<PosixThreadFactory> threadFactory = std::shared_ptr<PosixThreadFactory > (new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();
  TNonblockingServer server(processor, protocolFactory, serverTransport, threadManager);//using pool of thread
  
  // json zook_info;
  // if (!ps::MyOp::conf->getpszookeeper(zook_info)) {
  //   log_error("Fatal error! There is no zookeeper information file '%d'", 0);
  //   return -1;
  // }

  // const std::string zk_url = zook_info.at("zk_url");
  // std::string zk_path = zook_info.at("zk_path");
  // zk_path += model_name;

  // if (ps::MyOp::conf->getgroupid()) {
  //   gProxyServerRegister::serverRegiste2ZK(zk_url, zk_path, port, ps::MyOp::conf->groupid);
  // }
   

  server.serve();

  return 0;
}




