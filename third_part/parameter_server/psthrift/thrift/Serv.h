/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Serv_H
#define Serv_H

#include <TProcessor.h>
#include "my_server_types.h"



class ServIf {
 public:
  virtual ~ServIf() {}
  virtual void push(const std::map<Key, std::string> & key_vals) = 0;
  virtual void sync_push(const std::map<Key, std::string> & key_vals) = 0;
  virtual void pushemb(const std::map<Key, std::string> & key_vals) = 0;
  virtual void pushada(const std::map<Key, std::string> & key_vals) = 0;
  virtual void pull(std::map<Key, std::string> & _return, const std::set<Key> & keys) = 0;
  virtual void pull_online(std::map<Key, std::string> & _return, const std::set<Key> & keys) = 0;
  virtual void heartbeat(std::string& _return, const int32_t beat) = 0;
};

class ServIfFactory {
 public:
  typedef ServIf Handler;

  virtual ~ServIfFactory() {}

  virtual ServIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ServIf* /* handler */) = 0;
};

class ServIfSingletonFactory : virtual public ServIfFactory {
 public:
  ServIfSingletonFactory(const boost::shared_ptr<ServIf>& iface) : iface_(iface) {}
  virtual ~ServIfSingletonFactory() {}

  virtual ServIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ServIf* /* handler */) {}

 protected:
  boost::shared_ptr<ServIf> iface_;
};

class ServNull : virtual public ServIf {
 public:
  virtual ~ServNull() {}
  void push(const std::map<Key, std::string> & /* key_vals */) {
    return;
  }
  void sync_push(const std::map<Key, std::string> & /* key_vals */) {
    return;
  }
  void pushemb(const std::map<Key, std::string> & /* key_vals */) {
    return;
  }
  void pushada(const std::map<Key, std::string> & /* key_vals */) {
    return;
  }
  void pull(std::map<Key, std::string> & /* _return */, const std::set<Key> & /* keys */) {
    return;
  }
  void pull_online(std::map<Key, std::string> & /* _return */, const std::set<Key> & /* keys */) {
    return;
  }
  void heartbeat(std::string& /* _return */, const int32_t /* beat */) {
    return;
  }
};

typedef struct _Serv_push_args__isset {
  _Serv_push_args__isset() : key_vals(false) {}
  bool key_vals;
} _Serv_push_args__isset;

class Serv_push_args {
 public:

  Serv_push_args() {
  }

  virtual ~Serv_push_args() throw() {}

  std::map<Key, std::string>  key_vals;

  _Serv_push_args__isset __isset;

  void __set_key_vals(const std::map<Key, std::string> & val) {
    key_vals = val;
  }

  bool operator == (const Serv_push_args & rhs) const
  {
    if (!(key_vals == rhs.key_vals))
      return false;
    return true;
  }
  bool operator != (const Serv_push_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_push_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_push_pargs {
 public:


  virtual ~Serv_push_pargs() throw() {}

  const std::map<Key, std::string> * key_vals;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Serv_sync_push_args__isset {
  _Serv_sync_push_args__isset() : key_vals(false) {}
  bool key_vals;
} _Serv_sync_push_args__isset;

class Serv_sync_push_args {
 public:

  Serv_sync_push_args() {
  }

  virtual ~Serv_sync_push_args() throw() {}

  std::map<Key, std::string>  key_vals;

  _Serv_sync_push_args__isset __isset;

  void __set_key_vals(const std::map<Key, std::string> & val) {
    key_vals = val;
  }

  bool operator == (const Serv_sync_push_args & rhs) const
  {
    if (!(key_vals == rhs.key_vals))
      return false;
    return true;
  }
  bool operator != (const Serv_sync_push_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_sync_push_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_sync_push_pargs {
 public:


  virtual ~Serv_sync_push_pargs() throw() {}

  const std::map<Key, std::string> * key_vals;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_sync_push_result {
 public:

  Serv_sync_push_result() {
  }

  virtual ~Serv_sync_push_result() throw() {}


  bool operator == (const Serv_sync_push_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Serv_sync_push_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_sync_push_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_sync_push_presult {
 public:


  virtual ~Serv_sync_push_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Serv_pushemb_args__isset {
  _Serv_pushemb_args__isset() : key_vals(false) {}
  bool key_vals;
} _Serv_pushemb_args__isset;

class Serv_pushemb_args {
 public:

  Serv_pushemb_args() {
  }

  virtual ~Serv_pushemb_args() throw() {}

  std::map<Key, std::string>  key_vals;

  _Serv_pushemb_args__isset __isset;

  void __set_key_vals(const std::map<Key, std::string> & val) {
    key_vals = val;
  }

  bool operator == (const Serv_pushemb_args & rhs) const
  {
    if (!(key_vals == rhs.key_vals))
      return false;
    return true;
  }
  bool operator != (const Serv_pushemb_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_pushemb_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_pushemb_pargs {
 public:


  virtual ~Serv_pushemb_pargs() throw() {}

  const std::map<Key, std::string> * key_vals;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_pushemb_result {
 public:

  Serv_pushemb_result() {
  }

  virtual ~Serv_pushemb_result() throw() {}


  bool operator == (const Serv_pushemb_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Serv_pushemb_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_pushemb_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_pushemb_presult {
 public:


  virtual ~Serv_pushemb_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Serv_pushada_args__isset {
  _Serv_pushada_args__isset() : key_vals(false) {}
  bool key_vals;
} _Serv_pushada_args__isset;

class Serv_pushada_args {
 public:

  Serv_pushada_args() {
  }

  virtual ~Serv_pushada_args() throw() {}

  std::map<Key, std::string>  key_vals;

  _Serv_pushada_args__isset __isset;

  void __set_key_vals(const std::map<Key, std::string> & val) {
    key_vals = val;
  }

  bool operator == (const Serv_pushada_args & rhs) const
  {
    if (!(key_vals == rhs.key_vals))
      return false;
    return true;
  }
  bool operator != (const Serv_pushada_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_pushada_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_pushada_pargs {
 public:


  virtual ~Serv_pushada_pargs() throw() {}

  const std::map<Key, std::string> * key_vals;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_pushada_result {
 public:

  Serv_pushada_result() {
  }

  virtual ~Serv_pushada_result() throw() {}


  bool operator == (const Serv_pushada_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Serv_pushada_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_pushada_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_pushada_presult {
 public:


  virtual ~Serv_pushada_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Serv_pull_args__isset {
  _Serv_pull_args__isset() : keys(false) {}
  bool keys;
} _Serv_pull_args__isset;

class Serv_pull_args {
 public:

  Serv_pull_args() {
  }

  virtual ~Serv_pull_args() throw() {}

  std::set<Key>  keys;

  _Serv_pull_args__isset __isset;

  void __set_keys(const std::set<Key> & val) {
    keys = val;
  }

  bool operator == (const Serv_pull_args & rhs) const
  {
    if (!(keys == rhs.keys))
      return false;
    return true;
  }
  bool operator != (const Serv_pull_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_pull_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_pull_pargs {
 public:


  virtual ~Serv_pull_pargs() throw() {}

  const std::set<Key> * keys;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Serv_pull_result__isset {
  _Serv_pull_result__isset() : success(false) {}
  bool success;
} _Serv_pull_result__isset;

class Serv_pull_result {
 public:

  Serv_pull_result() {
  }

  virtual ~Serv_pull_result() throw() {}

  std::map<Key, std::string>  success;

  _Serv_pull_result__isset __isset;

  void __set_success(const std::map<Key, std::string> & val) {
    success = val;
  }

  bool operator == (const Serv_pull_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Serv_pull_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_pull_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Serv_pull_presult__isset {
  _Serv_pull_presult__isset() : success(false) {}
  bool success;
} _Serv_pull_presult__isset;

class Serv_pull_presult {
 public:


  virtual ~Serv_pull_presult() throw() {}

  std::map<Key, std::string> * success;

  _Serv_pull_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Serv_pull_online_args__isset {
  _Serv_pull_online_args__isset() : keys(false) {}
  bool keys;
} _Serv_pull_online_args__isset;

class Serv_pull_online_args {
 public:

  Serv_pull_online_args() {
  }

  virtual ~Serv_pull_online_args() throw() {}

  std::set<Key>  keys;

  _Serv_pull_online_args__isset __isset;

  void __set_keys(const std::set<Key> & val) {
    keys = val;
  }

  bool operator == (const Serv_pull_online_args & rhs) const
  {
    if (!(keys == rhs.keys))
      return false;
    return true;
  }
  bool operator != (const Serv_pull_online_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_pull_online_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_pull_online_pargs {
 public:


  virtual ~Serv_pull_online_pargs() throw() {}

  const std::set<Key> * keys;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Serv_pull_online_result__isset {
  _Serv_pull_online_result__isset() : success(false) {}
  bool success;
} _Serv_pull_online_result__isset;

class Serv_pull_online_result {
 public:

  Serv_pull_online_result() {
  }

  virtual ~Serv_pull_online_result() throw() {}

  std::map<Key, std::string>  success;

  _Serv_pull_online_result__isset __isset;

  void __set_success(const std::map<Key, std::string> & val) {
    success = val;
  }

  bool operator == (const Serv_pull_online_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Serv_pull_online_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_pull_online_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Serv_pull_online_presult__isset {
  _Serv_pull_online_presult__isset() : success(false) {}
  bool success;
} _Serv_pull_online_presult__isset;

class Serv_pull_online_presult {
 public:


  virtual ~Serv_pull_online_presult() throw() {}

  std::map<Key, std::string> * success;

  _Serv_pull_online_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Serv_heartbeat_args__isset {
  _Serv_heartbeat_args__isset() : beat(false) {}
  bool beat;
} _Serv_heartbeat_args__isset;

class Serv_heartbeat_args {
 public:

  Serv_heartbeat_args() : beat(0) {
  }

  virtual ~Serv_heartbeat_args() throw() {}

  int32_t beat;

  _Serv_heartbeat_args__isset __isset;

  void __set_beat(const int32_t val) {
    beat = val;
  }

  bool operator == (const Serv_heartbeat_args & rhs) const
  {
    if (!(beat == rhs.beat))
      return false;
    return true;
  }
  bool operator != (const Serv_heartbeat_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_heartbeat_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Serv_heartbeat_pargs {
 public:


  virtual ~Serv_heartbeat_pargs() throw() {}

  const int32_t* beat;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Serv_heartbeat_result__isset {
  _Serv_heartbeat_result__isset() : success(false) {}
  bool success;
} _Serv_heartbeat_result__isset;

class Serv_heartbeat_result {
 public:

  Serv_heartbeat_result() : success("") {
  }

  virtual ~Serv_heartbeat_result() throw() {}

  std::string success;

  _Serv_heartbeat_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const Serv_heartbeat_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Serv_heartbeat_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Serv_heartbeat_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Serv_heartbeat_presult__isset {
  _Serv_heartbeat_presult__isset() : success(false) {}
  bool success;
} _Serv_heartbeat_presult__isset;

class Serv_heartbeat_presult {
 public:


  virtual ~Serv_heartbeat_presult() throw() {}

  std::string* success;

  _Serv_heartbeat_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ServClient : virtual public ServIf {
 public:
  ServClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  ServClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void push(const std::map<Key, std::string> & key_vals);
  void send_push(const std::map<Key, std::string> & key_vals);
  void sync_push(const std::map<Key, std::string> & key_vals);
  void send_sync_push(const std::map<Key, std::string> & key_vals);
  void recv_sync_push();
  void pushemb(const std::map<Key, std::string> & key_vals);
  void send_pushemb(const std::map<Key, std::string> & key_vals);
  void recv_pushemb();
  void pushada(const std::map<Key, std::string> & key_vals);
  void send_pushada(const std::map<Key, std::string> & key_vals);
  void recv_pushada();
  void pull(std::map<Key, std::string> & _return, const std::set<Key> & keys);
  void send_pull(const std::set<Key> & keys);
  void recv_pull(std::map<Key, std::string> & _return);
  void pull_online(std::map<Key, std::string> & _return, const std::set<Key> & keys);
  void send_pull_online(const std::set<Key> & keys);
  void recv_pull_online(std::map<Key, std::string> & _return);
  void heartbeat(std::string& _return, const int32_t beat);
  void send_heartbeat(const int32_t beat);
  void recv_heartbeat(std::string& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ServProcessor : public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<ServIf> iface_;
  virtual bool process_fn(apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (ServProcessor::*)(int32_t, apache::thrift::protocol::TProtocol*, apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_push(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_sync_push(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pushemb(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pushada(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pull(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pull_online(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_heartbeat(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ServProcessor(boost::shared_ptr<ServIf> iface) :
    iface_(iface) {
    processMap_["push"] = &ServProcessor::process_push;
    processMap_["sync_push"] = &ServProcessor::process_sync_push;
    processMap_["pushemb"] = &ServProcessor::process_pushemb;
    processMap_["pushada"] = &ServProcessor::process_pushada;
    processMap_["pull"] = &ServProcessor::process_pull;
    processMap_["pull_online"] = &ServProcessor::process_pull_online;
    processMap_["heartbeat"] = &ServProcessor::process_heartbeat;
  }

  virtual bool process(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~ServProcessor() {}
};

class ServProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ServProcessorFactory(const ::boost::shared_ptr< ServIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< ServIfFactory > handlerFactory_;
};

class ServMultiface : virtual public ServIf {
 public:
  ServMultiface(std::vector<boost::shared_ptr<ServIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ServMultiface() {}
 protected:
  std::vector<boost::shared_ptr<ServIf> > ifaces_;
  ServMultiface() {}
  void add(boost::shared_ptr<ServIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void push(const std::map<Key, std::string> & key_vals) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->push(key_vals);
    }
  }

  void sync_push(const std::map<Key, std::string> & key_vals) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->sync_push(key_vals);
    }
  }

  void pushemb(const std::map<Key, std::string> & key_vals) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->pushemb(key_vals);
    }
  }

  void pushada(const std::map<Key, std::string> & key_vals) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->pushada(key_vals);
    }
  }

  void pull(std::map<Key, std::string> & _return, const std::set<Key> & keys) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->pull(_return, keys);
        return;
      } else {
        ifaces_[i]->pull(_return, keys);
      }
    }
  }

  void pull_online(std::map<Key, std::string> & _return, const std::set<Key> & keys) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->pull_online(_return, keys);
        return;
      } else {
        ifaces_[i]->pull_online(_return, keys);
      }
    }
  }

  void heartbeat(std::string& _return, const int32_t beat) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->heartbeat(_return, beat);
        return;
      } else {
        ifaces_[i]->heartbeat(_return, beat);
      }
    }
  }

};



#endif
