/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "galaxy_predict_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




ReqItem::~ReqItem() throw() {
}


void ReqItem::__set_id(const std::string& val) {
  this->id = val;
}

void ReqItem::__set_fids(const std::vector<int64_t> & val) {
  this->fids = val;
}
std::ostream& operator<<(std::ostream& out, const ReqItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ReqItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fids.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->fids.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI64(this->fids[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReqItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReqItem");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fids.size()));
    std::vector<int64_t> ::const_iterator _iter5;
    for (_iter5 = this->fids.begin(); _iter5 != this->fids.end(); ++_iter5)
    {
      xfer += oprot->writeI64((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReqItem &a, ReqItem &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.fids, b.fids);
  swap(a.__isset, b.__isset);
}

ReqItem::ReqItem(const ReqItem& other6) {
  id = other6.id;
  fids = other6.fids;
  __isset = other6.__isset;
}
ReqItem& ReqItem::operator=(const ReqItem& other7) {
  id = other7.id;
  fids = other7.fids;
  __isset = other7.__isset;
  return *this;
}
void ReqItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReqItem(";
  out << "id=" << to_string(id);
  out << ", " << "fids=" << to_string(fids);
  out << ")";
}


Model::~Model() throw() {
}


void Model::__set_name(const std::string& val) {
  this->name = val;
}

void Model::__set_use_multi(const bool val) {
  this->use_multi = val;
}

void Model::__set_tags(const std::vector<std::string> & val) {
  this->tags = val;
}
std::ostream& operator<<(std::ostream& out, const Model& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Model::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_multi);
          this->__isset.use_multi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tags.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->tags.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += iprot->readString(this->tags[_i12]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Model::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Model");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("use_multi", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->use_multi);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tags.size()));
    std::vector<std::string> ::const_iterator _iter13;
    for (_iter13 = this->tags.begin(); _iter13 != this->tags.end(); ++_iter13)
    {
      xfer += oprot->writeString((*_iter13));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Model &a, Model &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.use_multi, b.use_multi);
  swap(a.tags, b.tags);
  swap(a.__isset, b.__isset);
}

Model::Model(const Model& other14) {
  name = other14.name;
  use_multi = other14.use_multi;
  tags = other14.tags;
  __isset = other14.__isset;
}
Model& Model::operator=(const Model& other15) {
  name = other15.name;
  use_multi = other15.use_multi;
  tags = other15.tags;
  __isset = other15.__isset;
  return *this;
}
void Model::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Model(";
  out << "name=" << to_string(name);
  out << ", " << "use_multi=" << to_string(use_multi);
  out << ", " << "tags=" << to_string(tags);
  out << ")";
}


PredictReq::~PredictReq() throw() {
}


void PredictReq::__set_req_items(const std::vector<ReqItem> & val) {
  this->req_items = val;
}

void PredictReq::__set_models(const std::vector<Model> & val) {
  this->models = val;
}

void PredictReq::__set_handle_nums(const int16_t val) {
  this->handle_nums = val;
}
std::ostream& operator<<(std::ostream& out, const PredictReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PredictReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->req_items.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->req_items.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->req_items[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.req_items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->models.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->models.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += this->models[_i25].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.models = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->handle_nums);
          this->__isset.handle_nums = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PredictReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PredictReq");

  xfer += oprot->writeFieldBegin("req_items", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->req_items.size()));
    std::vector<ReqItem> ::const_iterator _iter26;
    for (_iter26 = this->req_items.begin(); _iter26 != this->req_items.end(); ++_iter26)
    {
      xfer += (*_iter26).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("models", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->models.size()));
    std::vector<Model> ::const_iterator _iter27;
    for (_iter27 = this->models.begin(); _iter27 != this->models.end(); ++_iter27)
    {
      xfer += (*_iter27).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handle_nums", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->handle_nums);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PredictReq &a, PredictReq &b) {
  using ::std::swap;
  swap(a.req_items, b.req_items);
  swap(a.models, b.models);
  swap(a.handle_nums, b.handle_nums);
  swap(a.__isset, b.__isset);
}

PredictReq::PredictReq(const PredictReq& other28) {
  req_items = other28.req_items;
  models = other28.models;
  handle_nums = other28.handle_nums;
  __isset = other28.__isset;
}
PredictReq& PredictReq::operator=(const PredictReq& other29) {
  req_items = other29.req_items;
  models = other29.models;
  handle_nums = other29.handle_nums;
  __isset = other29.__isset;
  return *this;
}
void PredictReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PredictReq(";
  out << "req_items=" << to_string(req_items);
  out << ", " << "models=" << to_string(models);
  out << ", " << "handle_nums=" << to_string(handle_nums);
  out << ")";
}


ResItem::~ResItem() throw() {
}


void ResItem::__set_id(const std::string& val) {
  this->id = val;
}

void ResItem::__set_tag_scores(const std::map<std::string, std::vector<double> > & val) {
  this->tag_scores = val;
}
std::ostream& operator<<(std::ostream& out, const ResItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tag_scores.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _ktype31;
            ::apache::thrift::protocol::TType _vtype32;
            xfer += iprot->readMapBegin(_ktype31, _vtype32, _size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              std::string _key35;
              xfer += iprot->readString(_key35);
              std::vector<double> & _val36 = this->tag_scores[_key35];
              {
                _val36.clear();
                uint32_t _size37;
                ::apache::thrift::protocol::TType _etype40;
                xfer += iprot->readListBegin(_etype40, _size37);
                _val36.resize(_size37);
                uint32_t _i41;
                for (_i41 = 0; _i41 < _size37; ++_i41)
                {
                  xfer += iprot->readDouble(_val36[_i41]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tag_scores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResItem");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tag_scores", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->tag_scores.size()));
    std::map<std::string, std::vector<double> > ::const_iterator _iter42;
    for (_iter42 = this->tag_scores.begin(); _iter42 != this->tag_scores.end(); ++_iter42)
    {
      xfer += oprot->writeString(_iter42->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(_iter42->second.size()));
        std::vector<double> ::const_iterator _iter43;
        for (_iter43 = _iter42->second.begin(); _iter43 != _iter42->second.end(); ++_iter43)
        {
          xfer += oprot->writeDouble((*_iter43));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResItem &a, ResItem &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.tag_scores, b.tag_scores);
  swap(a.__isset, b.__isset);
}

ResItem::ResItem(const ResItem& other44) {
  id = other44.id;
  tag_scores = other44.tag_scores;
  __isset = other44.__isset;
}
ResItem& ResItem::operator=(const ResItem& other45) {
  id = other45.id;
  tag_scores = other45.tag_scores;
  __isset = other45.__isset;
  return *this;
}
void ResItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResItem(";
  out << "id=" << to_string(id);
  out << ", " << "tag_scores=" << to_string(tag_scores);
  out << ")";
}


PredictRes::~PredictRes() throw() {
}


void PredictRes::__set_res_items(const std::map<std::string, ResItem> & val) {
  this->res_items = val;
}
std::ostream& operator<<(std::ostream& out, const PredictRes& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PredictRes::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->res_items.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _ktype47;
            ::apache::thrift::protocol::TType _vtype48;
            xfer += iprot->readMapBegin(_ktype47, _vtype48, _size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              std::string _key51;
              xfer += iprot->readString(_key51);
              ResItem& _val52 = this->res_items[_key51];
              xfer += _val52.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.res_items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PredictRes::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PredictRes");

  xfer += oprot->writeFieldBegin("res_items", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->res_items.size()));
    std::map<std::string, ResItem> ::const_iterator _iter53;
    for (_iter53 = this->res_items.begin(); _iter53 != this->res_items.end(); ++_iter53)
    {
      xfer += oprot->writeString(_iter53->first);
      xfer += _iter53->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PredictRes &a, PredictRes &b) {
  using ::std::swap;
  swap(a.res_items, b.res_items);
  swap(a.__isset, b.__isset);
}

PredictRes::PredictRes(const PredictRes& other54) {
  res_items = other54.res_items;
  __isset = other54.__isset;
}
PredictRes& PredictRes::operator=(const PredictRes& other55) {
  res_items = other55.res_items;
  __isset = other55.__isset;
  return *this;
}
void PredictRes::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PredictRes(";
  out << "res_items=" << to_string(res_items);
  out << ")";
}


